(define (make-level level-number initial-ant-pos)
  (let ((scorpion-time 0)
        (walls '())
        (scorpions '())
        (eggs '())
        (ant (make-movingobject initial-ant-pos 'right 'ant))
        (done? #f))


    ;;
    ;; ADD PROCEDURES
    ;;
    
    (define (add-wall position-object)
      (set! walls (cons (make-wall (make-position (position-object 'x) (+ (position-object 'y) top-border))) walls)))

    (define (add-vertical-wall start-position end-position)
      (let build-wall ((count (start-position 'y))
                       (x (start-position 'x)))
        (if (= count (end-position 'y))
            (add-wall (make-position x count))
            (begin
              (add-wall (make-position x count))
              (build-wall (+ count 1) x)))))

    (define (add-horizontal-wall start-position end-position)
      (let build-wall ((count (start-position 'x))
                       (y (start-position 'y)))
        (if (= count (end-position 'x))
            (add-wall (make-position count y))
            (begin
              (add-wall (make-position count y))
              (build-wall (+ count 1) y)))))

    ;; The main procedure that makes a long wall, it sees if you want to build a vertical or horizontal wall
    (define (add-multiple-walls position1 position2)
      (let ((x1 (position1 'x))
            (x2 (position2 'x))
            (y1 (position1 'y))
            (y2 (position2 'y)))
      (cond
        ((= x1 x2) (add-vertical-wall position1 position2))
        ((= y1 y2) (add-horizontal-wall position1 position2))
        (else (error "Cannot make walls diagonally!")))))

    (define (add-scorpion position-object orientation)
      (set! scorpions (cons (make-movingobject position-object orientation 'scorpion) scorpions)))

    (define (add-egg position-object)
      (set! eggs (cons (make-egg position-object) eggs)))

    (define (initial-ant-pos! position-object)
      (set! initial-ant-pos position-object))

    ;;
    ;; COLLISION DETECTION
    ;;

    ;; Is the next position free?
    (define (free? moving-object direction kind)

      ;; Gives list with every wall it collides with
      (define (wall-collision-list direction)
        (map-object (lambda (wall-object) (upcomming-collision? wall-object direction)) walls))

      ;; Gives list with every egg it collides with
      (define (egg-collision-list direction)
        (map-object (lambda (egg-object) (collision? egg-object)) eggs))

      ;; Checks if there is going to be a collision
      (define (upcomming-collision? object direction)
        (let ((current-x ((moving-object 'position) 'x))
              (current-y ((moving-object 'position) 'y)))
          (cond
            ((eq? direction 'right) (((object 'position) 'equal?) (make-position (+ current-x 1) current-y)))
            ((eq? direction 'left) (((object 'position) 'equal?) (make-position (- current-x 1) current-y)))
            ((eq? direction 'up) (((object 'position) 'equal?) (make-position current-x (- current-y 1))))
            ((eq? direction 'down) (((object 'position) 'equal?) (make-position current-x (+ current-y 1)))))))

      (define (collision? object)
        (((object 'position) 'equal?) (moving-object 'position)))

      (cond
        ((eq? kind 'wall) (not (list? (member #t (wall-collision-list direction)))))
        (else (not (list? (member #t (egg-collision-list direction)))))))

    (define (remove-egg!)
      (let ((lst (reverse eggs)))
        (define (look-for-remove current remaining result)
          (cond
            ((null? lst) result)
            ((and (null? remaining) (((current 'position) 'equal?) (ant 'position))) (set! eggs result))
            ((((current 'position) 'equal?) (ant 'position)) (set! eggs (append result remaining)))
            (else (look-for-remove (car remaining) (cdr remaining) (cons current result)))))
        (look-for-remove (car lst) (cdr lst) '())))

    ;; Checks if an egg needs to be removed
    (define (check-eggs! key)
      (if (not (free? ant key 'egg))
          (begin
            (remove-egg!))))
    
    ;;
    ;; MOVING
    ;;

    (define (move-scorpion! delta-time)
      (define (opposite orientation)
        (cond
          ((eq? orientation 'right) 'left)
          ((eq? orientation 'left) 'right)
          ((eq? orientation 'up) 'down)
          ((eq? orientation 'down) 'up)))

      (define (move! scorpion)
        (if (free? scorpion (scorpion 'orientation) 'wall)
            (begin
              ((scorpion 'move!) 1)
              (set! scorpion-time 0))
            (begin
              ((scorpion 'orientation!) (opposite (scorpion 'orientation)))
              ((scorpion 'move!) 1)
              (set! scorpion-time 0))))
      (set! scorpion-time (+ scorpion-time delta-time))
      (if (> scorpion-time 600)
          (for-each-object move! scorpions)))

    (define (move-ant! key)
      (if (or (and (eq? key 'right) (free? ant key 'wall))
              (and (eq? key 'left) (free? ant key 'wall))
              (and (eq? key 'up) (free? ant key 'wall) (not (<= ((ant 'position) 'y) top-border)))
              (and (eq? key 'down) (free? ant key 'wall) (not (>= ((ant 'position) 'y) bottom-border))))
          (begin
            ((ant 'orientation!) key)
            ((ant 'move!) 1)
            (check-eggs! key))))
  
    (define (dispatch m)
      (cond
        ((eq? m 'add-wall) add-multiple-walls)
        ((eq? m 'walls) walls)
        ((eq? m 'add-scorpion) add-scorpion)
        ((eq? m 'scorpions) scorpions)
        ((eq? m 'add-egg) add-egg)
        ((eq? m 'eggs) eggs)
        ((eq? m 'initial-ant-pos!) initial-ant-pos!)
        ((eq? m 'ant) ant)
        ((eq? m 'move-ant!) move-ant!)
        ((eq? m 'move-scorpion!) move-scorpion!)
        ((eq? m 'check-eggs!) check-eggs!)
        ((eq? m 'done?) done?)
        (else  (error "[ERROR in LevelADT DISPATCH] Wrong message: ") (display m))))
    dispatch))